%{
    #include <iostream>
    #include "hw3_output.hpp"
    #include "Semantics.h"
    #include "TokensClasses.h"
    using namespace std;
    #define YYSTYPE Node*
    int yylex();
    extern int yylineno;
    void yyerror(const char* err);
%}

%union{
    Type* typeName;
    Op* op;
    Bool* bool;
    Cmd* cmd;
    Parenthesis* paren;
    Num* num;
    Id* id;
    Str* str;
    Annotation* anno;
    program program;
};
%typeName<program> program

%nonassoc <typeName> VOID;
%nonassoc <typeName> INT;
%nonassoc <typeName> BYTE;
%nonassoc <typeName> B;
%nonassoc <typeName> BOOL;
%nonassoc <anno> CONST;
%nonassoc <bool> TRUE;
%nonassoc <bool> FALSE;
%nonassoc <cmd> RETURN;
%nonassoc <cmd> WHILE;
%nonassoc <cmd> BREAK;
%nonassoc <cmd> CONTINUE;
%nonassoc <cmd> SC;
%nonassoc <cmd> COMMA;
%nonassoc <paren> LBRACE;
%nonassoc <paren> RBRACE;
%nonassoc <id> ID;
%nonassoc <num>  NUM;
%nonassoc <str> STRING;
%left <paren> LPAREN;
%left <paren> RPAREN;
%right <op> NOT;
%left  <op> MULT;
%left  <op> DIV;
%left  <op> PLUS;
%left  <op> MINUS;
%nonassoc <op> RELOPNONASSOC;
%left <op> RELOPLEFT;
%left <op> AND;
%left <op> OR;
%right <cmd> IF;
%right <cmd> ELSE;
%right <cmd> ASSIGN;

%%
program: m_glob funcs {$$ = program();};

funcs: /*epsilon*/{$$ = funcs()};|
        funcDecl funcs {$$ = funcs();};

funcDecl: retType ID m_newScope LPAREN formals RPAREN LBRACE statements RBRACE{$$ = funcsDecl($1, $2.IdStr, $5, $8);};

retType: typeName{$$ = retType($1);};
        |VOID{$$ = retType($1.typeName);};

formals: /*epsilon*/{$$ = formals();};
	|formalsVector{$$ = formals($1);};

formalsVector: formalDecl{$$ = formalsVector($1);};
	|formalDecl COMMA formalsVector{$$ = formalsVector($1, $3);};

formalDecl: typeAnnotation typeName ID{$$ = formalDecl($1,$2,id.IdStr);};

statements: statement{$$ = statements($1);}
	|statements statement{$$ = statements($1, $2);};

statement: OpenStatement {$$ = statement($1);}
	|ClosedStatement {$$ = statement($1);};

OpenStatement: IF LPAREN m_newScope exp RPAREN statement{$$ = OpenStatement($1.keyWord, $4, $6);}
		|IF LPAREN m_newScope exp RPAREN ClosedStatement m_endScope ELSE m_newScope OpenStatement{$$ = OpenStatement($1.keyWord, $4, $6, $8.keyWord, $10);}
		|WHILE m_newScopeWhile LPAREN exp RPAREN OpenStatement{$$ = OpenStatement($1.keyWord, $4, $6);};

ClosedStatement:SimpleStatement {$$ = ClosedStatement($1);}
		|IF m_newScope LPAREN exp RPAREN ClosedStatement ELSE m_newScope ClosedStatement{$$ = ClosedStatement($1.keyWord,$4, $6, $7,$9);}
		|WHILE m_newScopeWhile LPAREN exp RPAREN ClosedStatement{$$ = ClosedStatement($1.keyWord, $4, $6);};

SimpleStatement: LBRACE m_newScope statements RBRACE{$$ =SimpleStatement($3);} //TODO - Maybe we need to perform the m_nesScope() function here
	|typeAnnotation typeName ID SC{$$ = SimpleStatement($1,$2,$3.IdStr);}
	|typeAnnotation typeName ID ASSIGN exp SC{$$ = SimpleStatement($1,$2,$3.IdStr,$5);}
	|ID ASSIGN exp SC{$$ = SimpleStatement($1.IdStr, $2, $3);}
	|call SC{$$ = SimpleStatement($1);}
	|RETURN SC{$$ = SimpleStatement($1.keyWord);}
	|RETURN exp SC{$$ = SimpleStatement($2);}
	|BREAK SC{$$ = SimpleStatement($1.keyWord);}
	|CONTINUE SC{$$ = SimpleStatement($1.keyWord);};

call: ID LPAREN expList RPAREN{$$ = call($1.IdStr,$3);};
	|ID LPAREN RPAREN{$$ = call($1.IdStr);};

expList: exp{$$ = expList($1);};
	|exp COMMA expList{$$ = expList($1,$3);};

typeName: INT{$$ = typeName($1.typeName);};
	|BYTE{$$ = typeName($1.typeName);};
	|BOOL{$$ = typeName($1.typeName);};

typeAnnotation: /*epsilon*/{$$ = typeAnnotation();};
		|CONST{$$ = typeAnnotation($1.annoType);};


exp: LPAREN exp RPAREN{$$ = exp($2);};
	|exp MULT exp{$$ = exp($1, $2.op, $3);};
	|exp DIV exp{$$ = exp($1, $2.op, $3);};
	|exp PLUS exp{$$ = exp($1, $2.op, $3);};
	|exp MINUS exp{$$ = exp($1, $2.op, $3);};
	|ID{$$ = exp($1.IdStr);};
	|call{$$ = exp($1);};
	|NUM{$$ = exp($1.val);};
	|NUM B{$$ = exp($1.val, true);};
	|STRING{$$ = exp($1.str);};
	|TRUE{$$ = exp($1.val);};
	|FALSE{$$ = exp($1.val);};
	|NOT exp{$$ = exp($1.op, $2);};
	|exp AND exp{$$ = exp($1, $2.op, $3);};
	|exp OR exp{$$ = exp($1, $2.op, $3);};
	|exp RELOPNONASSOC exp{$$ = exp($1, $2.op, $3);};
	|exp RELOPLEFT exp{$$ = exp($1, $2.op, $3);};
	|LPAREN typeAnnotation typeName RPAREN exp{$$ = exp($2, $3, $5);};

m_glob: /*epsilon*/     {Semantics::m_glob();};

m_newScope: /*epsilon*/ {Semantics::m_newScope();};

m_newScopeWhile: /*epsilon*/    {Semantics::m_newScopeWhile();};

m_endScope: /*epsilon*/         {Semantics::m_endScope();};
%%

void yyerror (const char* err) {
    hw3_output::errorSyn(yylineno);
    exit(0);
}
int main() {
    return yyparse();
}