%{
    #include <iostream>
    #include "hw3_output.hpp"
    #include "Semantics.h"
    using namespace std;
    int yylex();
    extern int yylineno;
    void yyerror(const char* err);
%}

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc CONST;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc LBRACE;
%nonassoc RBRACE;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%left LPAREN;
%left RPAREN;
%right NOT;
%left MULT;
%left DIV;
%left PLUS;
%left MINUS;
%nonassoc RELOPNONASSOC;
%left RELOPLEFT;
%left AND;
%left OR;
%right IF;
%right ELSE;
%right ASSIGN;

%%
program: m_glob funcs {$$ = new program()};

funcs: /*epsilon*/{$$ = new funcs()};|
        funcDecl funcs {$$ = new funcs()};

funcDecl: retType ID m_newScope LPAREN formals RPAREN LBRACE statements RBRACE{$$ = new funcsDecl(
                                                                                    dynamic_cast<retType*>($1),
                                                                                    $2,
                                                                                    dynamic_cast<formals*>($5),
                                                                                    dynamic_cast<statements*>($8));
                                                                                    };

retType: type{$$ = new retType(dynamic_cast<type*>($1))};
        |VOID{$$ = new retType($1);};

formals: /*epsilon*/{$$ = new formals();};
	|formalsList{$$ = new formals(dynamic_cast<formalsList*>($1));};

formalsList: formalDecl{$$ = new formalsList(dynamic_cast<formalsDecl*>($1));};
	|formalDecl COMMA formalsList{$$ = new formalsList(dynamic_cast<formalsDecl*>($1), dynamic_cast<formalsList*>($3));};

formalDecl: typeAnnotation type ID{$$ = new formalsDecl(dynamic_cast<typeAnnotation*>($1)
                                                        ,dynamic_cast<type*>($2),
                                                        $3);};

statements: statement{$$ = new statements(dynamic_cast<statement*>($1));}
	|statements statement{$$ = new statements(dynamic_cast<statements*>($1), dynamic_cast<statement*>($2));};

statement: OpenStatement {$$ = new statement(dynamic_cast<OpenStatement*>($1));}
	|ClosedStatement {$$ = new statement(dynamic_cast<ClosedStatement*>($1));};

OpenStatement: IF LPAREN m_newScope exp RPAREN statement{$$ = new OpenStatement("IF",
                                                                                dynamic_cast<exp*>($4),
                                                                                dynamic_cast<statement*>($6),
                                                                                $1->lineNum);}
		|IF LPAREN m_newScope exp RPAREN ClosedStatement  ELSE m_endScope m_newScope OpenStatement{$$ = new OpenStatement("IF",
                                                                                                                        dynamic_cast<exp*>($4),
                                                                                                                        dynamic_cast<ClosedStatement*>($6),
                                                                                                                        "ELSE",
                                                                                                                        dynamic_cast<OpenStatement*>($10),
                                                                                                                        $1->lineNum);}
		|WHILE m_newScopeWhile LPAREN exp RPAREN OpenStatement{$$ = new OpenStatement("WHILE",
		                                                                              dynamic_cast<exp*>($4),
		                                                                              dynamic_cast<OpenStatement*>($6),
		                                                                              $1->lineNum);};

ClosedStatement:SimpleStatement {$$ = new ClosedStatement(dynamic_cast<SimpleStatement*>($1));}
		|IF m_newScope LPAREN exp RPAREN ClosedStatement ELSE m_newScope ClosedStatement{$$ = new ClosedStatement("IF",
		                                                                                                          dynamic_cast<exp*>($4),
		                                                                                                          dynamic_cast<ClosedStatement*>($6),
		                                                                                                          "ELSE",
		                                                                                                          dynamic_cast<ClosedStatement*>($9),
		                                                                                                          $1->lineNum);}
		|WHILE m_newScopeWhile LPAREN exp RPAREN ClosedStatement{$$ = new ClosedStatement("WHILE",
                                                                                            dynamic_cast<exp*>($4),
                                                                                            dynamic_cast<ClosedStatement*>($6),$1->lineNum);};

SimpleStatement: LBRACE m_newScope statements RBRACE{$$ = new SimpleStatement(dynamic_cast<statements*>($3));} //TODO - Maybe we need to perform the m_nesScope() function here
	|typeAnnotation type ID SC{$$ = new SimpleStatement(dynamic_cast<typeAnnotation*>($1),
                                                        dynamic_cast<type*>($2),
                                                        $3);}
	|typeAnnotation type ID ASSIGN exp SC{$$ = new SimpleStatement(dynamic_cast<typeAnnotation*>($1),
                                                                   dynamic_cast<type*>($2),
                                                                   $3,dynamic_cast<exp*>($5));}
	|ID ASSIGN exp SC{$$ = new SimpleStatement($1, "ASSIGN", dynamic_cast<exp*>($3));}
	|call SC{$$ = new SimpleStatement(dynamic_cast<call*>($1));}
	|RETURN SC{$$ = new SimpleStatement($1);}
	|RETURN exp SC{$$ = new SimpleStatement($1, dynamic_cast<exp*>($2));}
	|BREAK SC{$$ = new SimpleStatement($1);}
	|CONTINUE SC{$$ = new SimpleStatement($1);};

call: ID LPAREN expList RPAREN{$$ = new call($1, dynamic_cast<expList*>($3));};
	|ID LPAREN RPAREN{$$ = new call($1);};

expList: exp{$$ = new expList(dynamic_cast<exp*>($1));};
	|exp COMMA expList{$$ = new expList(dynamic_cast<exp*>($1),dynamic_cast<expList*>(3));};

type: INT{$$ = new type($1.type);};
	|BYTE{$$ = new type($1.type);};
	|BOOL{$$ = new type($1.type);};

typeAnnotation: /*epsilon*/{$$ = new typeAnnotation();};
		|CONST{$$ = new typeAnnotation($1.annoType);};


exp: LPAREN exp RPAREN{$$ = new exp($2);};
	|exp MULT exp{$$ = new exp($1, $2.op, $3);};
	|exp DIV exp{$$ = new exp($1, $2.op, $3);};
	|exp PLUS exp{$$ = new exp($1, $2.op, $3);};
	|exp MINUS exp{$$ = new exp($1, $2.op, $3);};
	|ID{$$ = new exp($1.IdStr,"ID");};
	|call{$$ = new exp($1);};
	|NUM{$$ = new exp($1.val);};
	|NUM B{$$ = new exp($1.val, true);};
	|STRING{$$ = new exp($1.str,"STRING");};
	|TRUE{$$ = new exp($1.val);};
	|FALSE{$$ = new exp($1.val);};
	|NOT exp{$$ = new exp($1.op, $2);};
	|exp AND exp{$$ = new exp($1, $2.op, $3);};
	|exp OR exp{$$ = new exp($1, $2.op, $3);};
	|exp RELOPNONASSOC exp{$$ = new exp($1, $2.op, $3);};
	|exp RELOPLEFT exp{$$ = new exp($1, $2.op, $3);};
	|LPAREN typeAnnotation type RPAREN exp{$$ = new exp($2, $3, $5);};

m_glob: /*epsilon*/     {Semantics::m_glob();};

m_newScope: /*epsilon*/ {Semantics::m_newScope();};

m_newScopeWhile: /*epsilon*/    {Semantics::m_newScopeWhile();};

m_endScope: /*epsilon*/         {Semantics::m_endScope();};
%%

void yyerror (const char* err) {
    hw3_output::errorSyn(yylineno);
    exit(0);
}
int main() {
    return yyparse();
}